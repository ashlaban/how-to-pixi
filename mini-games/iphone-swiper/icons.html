<html>
<head>
    <title>Icons Test</title>

    <meta name="viewport" content="user-scalable=no, width=device-width, initial-scale=1" />

    <link rel="stylesheet" type="text/css" href="css/HexStyle.css">

    <script src="lib/pixi.js"></script>
    <script src="lib/hammer.min.js"></script>

    <script src="js/HexUtil.js"></script>
    <script src="js/HexAnimationSystem.js"></script>

    <script src="js/HexMath.js"></script>
    <script src="js/HexCoordinate.js"></script>
    <script src="js/HexCell.js"></script>
</head>

<body>
    <div id='main' class='flex-container flex-vertical'>
    <div id='content-wrapper'>
        <div class='well top'>
            <h1>iPhone Swipe Thing</h1>
        </div>
        <div id='content' class='flex-container flex-vertical'>
            <div id="canvas-wrapper" class='well middle'></div>
            <div id='side-panel' class='flex-container flex-vertical well middle'></div>
        </div>
        <div class='well bottom'>
            <h2>First section</h2>
            <hr class="section-divider">
            <p>Just adding some test text to the bottom of the page. I am also going to fill the whole paragraph, just to try out the layout and such with different fonts and settings.</p>
            <p>This is a second paragraph, aimed to test the spacing between two different paragraphs.</p>
            <h2>Second section</h2>
            <hr class="section-divider">
            <p>A third paragraph with some additional information and text and things like this. Now the documents is starting to look like something that could have been part of the description for a mini-game.</p>
        </div>
    </div>
    </div>
    <script>
    // Set up the PIXI renderer
    var canvas = {width: 500, height: 300};
    var renderer = new PIXI.WebGLRenderer   (
                                                canvas.width,
                                                canvas.height,
                                                {
                                                    transparent : true,
                                                    antialias   : true,
                                                    resolution  : window.devicePixelRatio
                                                }
                                            );
    document.getElementById('canvas-wrapper').appendChild(renderer.view);
    renderer.view.style.width     = canvas.width;
    renderer.view.style.height    = canvas.height;
    renderer.view.style.minWidth  = canvas.width;
    renderer.view.style.minHeight = canvas.height;
    renderer.view.style.maxWidth  = canvas.width;
    renderer.view.style.maxHeight = canvas.height;

    var container = new PIXI.Container();

    // TODO: Paint an example icon.
    var position = {x:canvas.width/2, y:canvas.height/2};
    var scale    = {x:100, y:100};
    var color    = 0x0069A9;
    var conf     = {
                    stroke: {color:0x00, width:0.01}, 
                    edge  : {color:0xdd0000, width:0.2},
                    radial: {
                             vertex:{color:0xffcd00, width:0.18},
                             side  :{color:0xffcd00, width:0.3}
                            }
                   };
    gridconf = {
            position : { x: 50, y: 60 },
            scale    : { x: 30, y: 30 },
            size     : { w: 10, h: 5 },
        }
    gridconf.cell = conf;

    cell = new HexCell(position, scale, color, conf);
    cell.edges             = [];
    cell.radialVertexLines = [1, 4];
    cell.radialSideLines   = [0, 3];
    cell.draw();
    // cell.renderWith(renderer);

    position = {x:1000+canvas.width/2, y:canvas.height/2};
    scale    = {x:100, y:100};
    color    = 0xff69A9;
    conf     = {
                    stroke: {color:0x00, width:0.01}, 
                    edge  : {color:0xdd0000, width:0.2},
                    radial: {
                             vertex:{color:0xffcd00, width:0.18},
                             side  :{color:0xffcd00, width:0.3}
                            }
                   };
    gridconf = {
            position : { x: 50, y: 60 },
            scale    : { x: 30, y: 30 },
            size     : { w: 10, h: 5 },
        }
    gridconf.cell = conf;
    cell2 = new HexCell(position, scale, color, conf);
    cell2.edges             = [];
    cell2.radialVertexLines = [1, 4];
    cell2.radialSideLines   = [0, 3];
    cell2.draw();
    // cell2.renderWith(renderer);
     
    position = {x:-1000+canvas.width/2, y:canvas.height/2};
    scale    = {x:100, y:100};
    color    = 0x009949;
    conf     = {
                    stroke: {color:0x00, width:0.01}, 
                    edge  : {color:0xdd0000, width:0.2},
                    radial: {
                             vertex:{color:0xffcd00, width:0.18},
                             side  :{color:0xffcd00, width:0.3}
                            }
                   };
    gridconf = {
            position : { x: 50, y: 60 },
            scale    : { x: 30, y: 30 },
            size     : { w: 10, h: 5 },
        }
    gridconf.cell = conf;
    cell3 = new HexCell(position, scale, color, conf);
    cell3.edges             = [];
    cell3.radialVertexLines = [1, 4];
    cell3.radialSideLines   = [0, 3];
    cell3.draw();
    
    container.addChild(cell._graphics);
    container.addChild(cell2._graphics);
    container.addChild(cell3._graphics);
    renderer.render(container);

    
    // function randomiseIconCell(offsetCoord, linearCoord, cell) {
    //     function randomInt(min, max) {
    //         return min + Math.floor(Math.random()*(max-min+1))
    //     }
    //     function randomArray(min, max, nElem) { 
    //         a = [];
    //         while (a.length < nElem) {
    //             var n = randomInt(min, max);
    //             for (var i = a.length - 1; i >= 0; i--) {
    //                 if (a[i]==n) {continue;}
    //             };
    //             a.push(n);
    //         };
    //         return a;
    //     }

    //     cell.color = color;

    //     nEdgeLines = randomInt(0,5);
    //     nSideLines = randomInt(0,5);
    //     nVertLines = randomInt(0,5);
    //     edges      = randomArray(0, 5, nEdgeLines);
    //     sides      = randomArray(0, 5, nSideLines);
    //     verts      = randomArray(0, 5, nVertLines);

    //     cell.edges             = edges;
    //     cell.radialVertexLines = verts;
    //     cell.radialSideLines   = sides;

    //     var x = Math.random();
    //     var y = Math.random();
    //     var z = Math.random();
    //     cell.radialVertexLineWidth = x;
    //     cell.radialSideLineWidth   = y;
    //     cell.edgeWidth             = z;
    // }
    
    // grid = new HexGrid(gridconf, null);
    // grid.applyToCells(randomiseIconCell)
    // grid.draw();
    // grid.renderWith(renderer);

    function WiggleCellAnimationFactory (cell, duration, span, isRepeating) {

        var startTime = performance.now();
        var endTime   = startTime + duration;
        var startX    = cell._graphics.position.x;

        var temp;
        var endX = startX + span;

        var wiggle = function (dt, currentTime) {

            var t = currentTime - startTime;

            var x = HexMath.easeInOutQuad(t, startX, span, duration);
            cell._graphics.position.x = x;
            renderer.render(container); // TODO: abstract rendering of scene!

            // Repeating function
            if (isRepeating && t > duration) {
                startTime = performance.now();
                endTime   = startTime + duration;

                temp   = startX;
                startX = endX;
                endX   = temp;

                span     *= -1;
            }
            
            if (!isRepeating && t>duration) return true;

            return false;
        }
        return wiggle;
    }

    var animationSystem = new HexAnimationSystem.AnimationSystem();
    // animationSystem.add(WiggleCellAnimationFactory(cell, 2000, 200));
    
    // Kick-start the animation
    animationSystem.animate();

    var mc = Hammer(renderer.view);
    mc.on('swipe', function (ev) {
        var dur  = 850;
        var dist = 1000;
        if (ev.angle > 135 || ev.angle < -135) {
            animationSystem.add(WiggleCellAnimationFactory(cell , dur, -dist));
            animationSystem.add(WiggleCellAnimationFactory(cell2, dur, -dist));
            animationSystem.add(WiggleCellAnimationFactory(cell3, dur, -dist));
        } else if (ev.angle < 45 || ev.angle > -45) {
            animationSystem.add(WiggleCellAnimationFactory(cell , dur,  dist));
            animationSystem.add(WiggleCellAnimationFactory(cell2, dur,  dist));
            animationSystem.add(WiggleCellAnimationFactory(cell3, dur,  dist));
        }
        // console.log(ev)
    })

    // document.body.ontouchstart = function(ev) {
    //     console.log('test')
    // };
    // renderer.view.onmousemove = function(ev) {
    //     isCellDirty = true;

    //     // console.log(ev);
    //     updateCellAnimation(cell, ev.offsetX)
    // };
    
    </script>
</body>
</html>